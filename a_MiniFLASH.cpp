//-----------------------------------------------------------------------------
//   Copyright (C) Siemens Healthcare GmbH, 2015-2018. All Rights Reserved. Confidential.
//-----------------------------------------------------------------------------
//
//  \file   \src\MrImagingFW\seq\a_MiniFLASH\a_MiniFLASH.cpp
//
//  \brief  This is the demo sequence MiniFLASH.
//          DO NOT base any diagnosis on images generated by this sequence.
//
//////////////////////////////////////////////////////////////////////////////////////////
//
//                                MiniFLASH Sequence Diagram
//
//                       |-----------TE---------------|
//
//              RF --|m_sSRF01|----------------------------------------------
//
//              Gs -|m_sGSliSel|-|m_sGSliSelReph|-----------|m_sGSpoil|------
//
//              Gp --------------|m_sGPhasEnc|--------------|m_sGPhasEncRew|-
//
//              Gr --------------|m_sGReadDeph|---|m_sGradRO|----------------
//
//             ADC --------------------------------|m_sADC01|----------------
//
//                |------------------------------TR--------------------------|
//
///////////////////////////////////////////////////////////////////////////////////////////

#include "a_MiniFLASH.h"

#include "a_MiniFLASH_UI.h"

#include "MrImaging/libSBB/libSBBmsg.h"                                 // SBB_... error codes
#include "MrImaging/seq/SystemProperties.h"                             // Siemens system properties
#include "MrImagingFW/libSeqSysProp/SysProperties.h"                    // System properties ("imprint" data)
#include "MrImagingFW/libSeqUTIF/libsequt.h"                            // Unit Test
#include "MrMeasSrv/SeqIF/Sequence/sequmsg.h"                           // Messages
#include "MrMeasSrv/SeqIF/csequence.h"                                  // Sequence enumerations
#include "MrProtSrv/Domain/MrProtData/MrProt/KSpace/MrKSpace.h"         // KSpace
#include "MrProtSrv/Domain/MrProtData/MrProt/MeasParameter/MrRXSpec.h"  // MrRXSpec
#include "MrProtSrv/Domain/MrProtData/MrProt/MeasParameter/MrSysSpec.h" // GradSpec

#include <cmath>
#ifdef WIN64
#include <tchar.h>
#endif

// Macro: return S, if S is an error code (applies to functions returning MRRESULT-values)
#define OnErrorReturn(S) \
    if (!MrSucceeded(S)) \
    return (S)

#ifndef SEQ_NAMESPACE
#error SEQ_NAMESPACE not defined
#endif

//  --------------------------------------------------------------------------
//
//  Name        :  SEQIF_DEFINE
//
//  Description :
///  \brief        Create instance of the sequence
//
//  Return      :  SeqIF *
//
//  --------------------------------------------------------------------------
#ifdef SEQUENCE_CLASS_MiniFLASH
SEQIF_DEFINE(SEQ_NAMESPACE::MiniFlash)
#endif
using namespace SEQ_NAMESPACE;

MiniFlash::MiniFlash() : m_WIPParamTool(*this)
{
    // no further instructions...
}

// NJM: calculate duration of diffusion gradient to achieve b-value 
int32_t MiniFlash::calcdelta(int32_t tramp, int32_t tsep, int32_t traster, double bval, double gamp)
{
    // NJM: this will be the return value 
    int32_t tdelta = 0;

    double TWOPI_GAM = 26751.0;

    int i,j;
    double temp;
    double BETA;
    double root[3];
    double a,b,c;
    double Q,R,Rsq,Qcub,theta;
    double sep, ramp;
    double bvalcheck, calcdel;

    sep = (double)(tsep)/1.e6;
    ramp = (double)(tramp)/1.e6;    

    BETA = TWOPI_GAM*TWOPI_GAM*(gamp/100.0)*(gamp/100.0);

    a = (3.0*sep)/2;
    b = (-1.0*ramp*ramp)/4;
    c = (-3.0*bval)/(2*BETA) + (ramp*ramp*ramp)/20.0;

    Q = (double)((a*a-3.0*b)/9.0);
    R = (double)((2.0*(a*a*a)- 9.0*a*b + 27*c)/54.0);
    Rsq = (double)(R*R);
    Qcub = (double)(Q*Q*Q);

    if (Rsq < Qcub)
    {

        theta = acos(R/sqrt(Qcub));

        /* cast roots in terms of us */
        root[0] = 1e6*(-2.0*sqrt(Q)*cos(theta/3.0) - a/3.0);
        root[1] = 1e6*(-2.0*sqrt(Q)*cos((theta+2.0*M_PI)/3.0) - a/3.0);
        root[2] = 1e6*(-2.0*sqrt(Q)*cos((theta-2.0*M_PI)/3.0) - a/3.0);
        
        /* order roots and take the smallest - non negative value */
        for (i=0; i<=2; i++)
        {
            temp = root[i];
            for (j=i+1; j<=2; j++)
            {
                if (root[j] < temp)
                {
                    root[i] = root[j];
                    root[j] = temp;
                    temp = root[i];
                }
            }
        }

        /* take smallest that is larger than GRAD_RASTER_TIME */
        if (root[0] > traster)
            tdelta = (int32_t)root[0];
        else if (root[1] > traster)
            tdelta = (int32_t)root[1];
        else if (root[2] > traster)
            tdelta = (int32_t)root[2];
            

    }
    else {

        double sign;
        double A,B;

        /* check sign of R */
        if (R >= 0)
            sign = 1.0;
        else
            sign = -1.0;

        A = -sign*pow((double)(fabs(R) + sqrt(Rsq-Qcub)),1.0/3);
        B = Q/A;

        /* This is the only real root - the other two are complex */
        root[0] = 1e6*(float)(A + B - a/3.0);

        if(root[0] >= traster)
            tdelta = (long)root[0];
        
    }

    return tdelta;
}

//   -------------------------------------------------------------------------
//   MiniFlash::initialize
//   Initialize the allowed Sequence Limits.
//   These entries enable user interface parameters in the exam window,
//   or initialize other parameters of the sequence.
//   -------------------------------------------------------------------------

NLSStatus MiniFlash::initialize(SeqLim& rSeqLim)
{
    // Default return value
    NLS_STATUS lStatus = MRI_SEQ_SEQU_NORMAL;

    //  The parameters in this group have no meaningful default value (zero or not specified in SeqLim).

    // clang-format off
    //                                (        min,        max)
    rSeqLim.setAllowedFrequency     (    8000000,  500000000);                         // Always refers to 1H frequency

    //                                (index,  min,        max,    increment,  default)
    rSeqLim.setTR                   (    0,  100,    5000000,           10,    20000);
    rSeqLim.setTE                   (    0,  100,     100000,           10,    10000);
    rSeqLim.setBandWidthPerPixel    (    0,   80,        900,           10,      260);

    //                              (        min,        max,    increment,  default)
    rSeqLim.setFlipAngle            (       10.0,       90.0,          1.0,   15.000);


    //  These parameters have default values, yet are added for convenience

    //                              (        min,        max,    increment,  default)
    rSeqLim.setBaseResolution       (         64,        512,  SEQ::INC_64,      128); // INC_BASE2 also available
    rSeqLim.setReadoutFOV           (        100,        500,            1,      300); // mm
    rSeqLim.setPhaseFOV             (        100,        500,            1,      300); // mm
    rSeqLim.setPELines              (         32,       1024,            1,      128);
    rSeqLim.setSlices               (          1,          1,            1,        1); // Only single slice!
    rSeqLim.setSliceThickness       (      2.000,     10.000,        0.500,    5.000); // mm



    // NJM: for splice
    rSeqLim.setContrasts(2,2,1,2);
    rSeqLim.setTE( 1, 100, 100000, 10, 10000);
    // clang-format on


    // --------------------------------------------------------------------------------------------
    // Define Distortion Correction Limits
    // --------------------------------------------------------------------------------------------
    //

    // Omit the NDIS mode for NX based sequence, because GSP will not display images without
    // distortion correction.
    //
    // Distortion Correction Mode:  DISTCORR_NDIS
    //                              DISTCORR_DIS2D
    //                              DISTCORR_DIS3D

    rSeqLim.setDistortionCorrMode(SEQ::DISTCORR_DIS2D);

    // --------------------------------------
    // Instantiation of the MiniFlashUI class
    // --------------------------------------

    // This compiler directive restricts this code to the Host version dll.
    // In this way the same source code can be compiled for both the Host and the MARS,
    // but different portions of the code can be restricted to one processor.
    // WIN32 is a standard preprocessor flag. User-defined flags are in the makefile.trs.

    SequenceUIFactory<MiniFlashUI> rObjectFactory;
    auto                           pUI = createUI<MiniFlashUI, MiniFlash>(rObjectFactory, rObjectFactory.DEFAULTSEQUINAME, this);
    if (nullptr == pUI)
    {
        MRTRACE("MiniFlashUI object pointer is null (creation failed probably)!");
        return MRI_SEQ_SEQU_ERROR;
    }

    // ----------------------------------------------
    // Declaration of pointer to UI parameter classes
    // ----------------------------------------------
    lStatus = pUI->registerUI(rSeqLim, m_WIPParamTool);
    if (MrSeverity(lStatus) != MRRESULT_SUCCESS)
    {
        MRTRACE("Registering MiniFlashUI object failed! Errorcode: %lu", lStatus);
        return lStatus;
    }

#ifdef WIN32
    // -----------------------------------------------------------------
    // file containing the default postprocessing protocol (EVAProtocol)
    // -----------------------------------------------------------------

    // The _T(x) macro deals with the Unicode conversion of strings.
    rSeqLim.setDefaultEVAProt(_T("%SiemensEvaDefProt%\\Inline\\Inline.evp"));

#endif

    return lStatus;
}

//  -------------------------------------------------------------------------
//   MiniFlash::prepare
//   Prepare real time elements and calculate energy and timing.
//   Values from MrProt are interpreted.
//. -------------------------------------------------------------------------
NLSStatus MiniFlash::prepare(MrProt& rMrProt, SeqLim& rSeqLim, MrProtocolData::SeqExpo& rSeqExpo)
{
    NLS_STATUS lStatus = MRI_SEQ_SEQU_NORMAL; // Default return value

    if (!m_WIPParamTool.prepare(rMrProt, rSeqLim))
        return MRI_SEQ_SEQU_ERROR;

    //  Retrieve some information about the scanner and define some convenient variables.
    //  Hardware information is stored in proxy files. The contents can be retrieved using SysProperties methods.
    m_dMinRiseTime = SysProperties::getGradMinRiseTime(rMrProt.gradSpec().mode()); // Minimum gradient rise time selected in protocol
    m_dGradMaxAmpl = SysProperties::getGradMaxAmpl(rMrProt.gradSpec().mode());     // Maximum gradient amplitude selected in protocol

    OnErrorReturn(rMrProt.kSpace().linesToMeasure(
        rMrProt.getsSliceArray().getasSlice()[0].getdReadoutFOV(),
        rMrProt.getsSliceArray().getasSlice()[0].getdPhaseFOV(),
        m_lLinesToMeasure));                     // Call by non-constant reference
    m_lCenterLine = rMrProt.kSpace().echoLine(); // 1/2 base resolution for symmetric PE

    const double dMeasureTimeUsec = static_cast<double>(m_lLinesToMeasure) * rMrProt.tr()[0];
    m_lLinesPerSec                = std::max<int32_t>(1, int32_t(m_lLinesToMeasure * 1000000.0 / dMeasureTimeUsec));
    rSeqExpo.setRelevantReadoutsForMeasTime(m_lLinesToMeasure / m_lLinesPerSec);

    // CONFIGURE RF PULSE PROPERTIES AND PREPARE:
    m_sSRF01.setTypeExcitation();                                      // Resets all moments to 0 in Unit test
    m_sSRF01.setDuration(2560);                                        // Most times are in microseconds
    m_sSRF01.setFlipAngle(rMrProt.flipAngle());                        // Sets flip angle based on UI (in degrees)
    m_sSRF01.setInitialPhase(0);                                       // Sets B1 orientation to 0 degrees (+x) in rotating frame
    m_sSRF01.setThickness(rMrProt.sliceSeries().aFront().thickness()); // Sets thickness based on UI (in mm)
    m_sSRF01.setSamples(128);                                          // Number of complex points in waveform
    m_sSRF01.setBandwidthTimeProduct(2.70);                            // Only sRF_PULSE_SINC objects have the BW*t attribute

    //  The following is a common error-checking code structure for pulse sequences.
    //  The prepare (prep) method returns a boolean indicating success or failure.
    //  If the returned boolean indicates failure, then exit prepare and return the NLS error code.
    if (!m_sSRF01.prepSinc(rMrProt, rSeqExpo))
        return m_sSRF01.getNLSStatus();

    // NJM: refocusing pulse
    m_sSRF_ref.setTypeRefocussing();                                      // Resets all moments to 0 in Unit test
    m_sSRF_ref.setDuration(2560);                                        // Most times are in microseconds
    m_sSRF_ref.setFlipAngle(120.0);                        // Sets flip angle based on UI (in degrees)
    m_sSRF_ref.setInitialPhase(90.0);                                       // Sets B1 orientation to 0 degrees (+x) in rotating frame
    m_sSRF_ref.setThickness(rMrProt.sliceSeries().aFront().thickness()); // Sets thickness based on UI (in mm)
    m_sSRF_ref.setSamples(128);                                          // Number of complex points in waveform
    m_sSRF_ref.setBandwidthTimeProduct(2.70);                            // Only sRF_PULSE_SINC objects have the BW*t attribute
    if (!m_sSRF_ref.prepSinc(rMrProt, rSeqExpo))
        return m_sSRF_ref.getNLSStatus();

    // PREPARE ADC:
    m_sADC01.setColumns(rMrProt.kSpace().getlBaseResolution());
    m_sADC01.setDwellTime(std::lround(rMrProt.rxSpec().effDwellTime(rSeqLim.getReadoutOSFactor())[0]));
    m_sADC01.getMDH().setKSpaceCentreColumn(static_cast<uint16_t>(rMrProt.kSpace().getlBaseResolution() / 2));

    // NJM: second ADC 
    m_sADC02.setColumns(rMrProt.kSpace().getlBaseResolution());
    m_sADC02.setDwellTime(std::lround(rMrProt.rxSpec().effDwellTime(rSeqLim.getReadoutOSFactor())[0]));
    m_sADC02.getMDH().setKSpaceCentreColumn(static_cast<uint16_t>(rMrProt.kSpace().getlBaseResolution() / 2));

    // An explicit preparation for the ADC is not necessary as setDwellTime() includes .prep

    // PREPARE THE READOUT GRADIENT:
    // The method .prepRO() sets only the amplitude based on the UI settings.
    // The ramp times and the duration need to be set separately.
    // Note that the duration is defined as the RampUpTime plus the FlatTopTime.
    // The method .check() ensures that amplitude and slew rate limits are not exceeded.
    if (!m_sGradRO.prepRO(rMrProt, static_cast<double>(m_sADC01.getDwellTime())))
        return m_sGradRO.getNLSStatus();
    m_sGradRO.setRampTimes(fSDSRoundUpGRT(m_dMinRiseTime * m_sGradRO.getAmplitude()));
    m_sGradRO.setDuration(fSDSRoundUpGRT(static_cast<double>(m_sGradRO.getRampUpTime()) + m_sADC01.getDuration()));
    if (!m_sGradRO.prep())
        return m_sGradRO.getNLSStatus();
    if (!m_sGradRO.check())
        return m_sGradRO.getNLSStatus();

    //  The start time of the readout gradient cannot be set because the slice select gradient timing has not
    //  been determined. Once the TE in the UI is known to be consistent (i.e. if it is greater than the minimum
    //  required TE), the start time can be set.

    // NJM: diffusion gradient duration calculation
    long ltsep = m_sGS_ref.getTotalTime() + m_sGS_rew_crush.getTotalTime() + m_sGS_crush.getTotalTime();
    int32_t diffDelta = calcdelta(500, ltsep, 10, 200.0, m_dGradMaxAmpl);
    m_sGS_Diff_ST.setMaxMagnitude(m_dGradMaxAmpl);
    m_sGS_Diff_ST.setMinRiseTime(m_dMinRiseTime);
    if (!m_sGS_Diff_ST.prepSymmetricTOTShortestTime(m_dGradMaxAmpl * (double)(diffDelta)))
        return (m_sGS_Diff_ST.getNLSStatus());
    //printf("NJM: duration of diff grad: %d\n", m_sGS_Diff_ST.getTotalTime());
    //SEQ_TRACE_DEBUG.print("NJM: duration of diff grad: %d", m_sGS_Diff_ST.getTotalTime());

    // NJM: calculate echo spacing 
    int32_t lMinEspCalcS = m_sGS_ref.getTotalTime()/2 + m_sGS_crush.getTotalTime() + m_sGradRO.getDuration() + m_sGradRO.getRampDownTime()/2 - m_sGradRO.getRampUpTime();
    int32_t lMinEspCalcP = m_sGS_ref.getTotalTime()/2 - m_sGS_ref.getRampDownTime() + m_sGPhasEnc.getTotalTime() + m_sGradRO.getDuration() + m_sGradRO.getRampDownTime()/2 - m_sGradRO.getRampUpTime();
    int32_t lMinEsp = 2 * MAX(lMinEspCalcS, lMinEspCalcP);

    // NJM: map echo spacing to echo time and enforce minimum
    if (lMinEsp > (rMrProt.te()[0]))
       return MRI_SBB_SBB_NEGATIV_TEFILL;

    // NJM: calculate prep time (TODO: fix this!!!!)
    //int32_t lMinPrepTimeL = m_sGSliSel.getTotalTime()/2 + m_sGS_Diff_ST.getTotalTime() + m_sGS_rew_crush.getTotalTime() + m_sGS_ref.getTotalTime()/2;
    int32_t lMinPrepTimeR = m_sGS_ref.getTotalTime()/2 + m_sGS_crush.getTotalTime() + m_sGS_Diff_ST.getTotalTime() + rMrProt.te()[0]/2;
    //m_lPrepTimeUs = fSDSRoundUpGRT(2 * MAX(lMinPrepTimeL, lMinPrepTimeR));
    m_lPrepTimeUs = 2 * lMinPrepTimeR;

    //  PREPARE AND CHECK THE PHASE ENCODING GRADIENT:
    //  First, chose maximum allowed value for gradient performance.
    m_sGPhasEnc.setMaxMagnitude(m_dGradMaxAmpl); // set highest performance value (maximum allowed gradient amplitude)
    m_sGPhasEnc.setMinRiseTime(m_dMinRiseTime);  // set highest performance value (shortest allowed gradient rise time)
    // rise time is 1/slew rate; unit of rise time is [us/(mT/m)]

    //  Second, prepare gradient for positive edge of k-space ...
    if (!m_sGPhasEnc.prepPEShortestTime(rMrProt, SEQ::DIR_ASCENDING, 0.0, m_lLinesToMeasure - m_lCenterLine - 1))
        return m_sGPhasEnc.getNLSStatus();

    //  .. and check if amplitude and rise time do not exceed maximum allowed values.
    if (!m_sGPhasEnc.check())
        return m_sGPhasEnc.getNLSStatus();

    //  Remember the duration, before preparing the other edge of k-space
    const int32_t lPhaseEncTotalTime = static_cast<int32_t>(m_sGPhasEnc.getTotalTime());

    //  Third, prepare gradient for negative edge of k-space ...
    if (!m_sGPhasEnc.prepPEShortestTime(rMrProt, SEQ::DIR_ASCENDING, 0.0, -m_lCenterLine))
        return m_sGPhasEnc.getNLSStatus();

    //  .. and check if amplitude and rise time do not exceed maximum allowed values.
    if (!m_sGPhasEnc.check())
        return m_sGPhasEnc.getNLSStatus();

    //  Take the longer duration of both edges by re-preparing the gradient, if needed
    if (lPhaseEncTotalTime > m_sGPhasEnc.getTotalTime())
    {
        if (!m_sGPhasEnc.prepPEShortestTime(rMrProt, SEQ::DIR_ASCENDING, 0.0, m_lLinesToMeasure - m_lCenterLine - 1))
            return m_sGPhasEnc.getNLSStatus();
    }

    //  Copy timing info to PE rewinder as this gradient will have same timing (but opposite polarity) as phase encoder.
    m_sGPhasEncRew = m_sGPhasEnc;

    //  PREPARE AND CHECK THE SLICE SELECTION GRADIENT:
    //  First, set the gradient amplitude, retrieving it from the RF pulse object.
    m_sGSliSel.setAmplitude(m_sSRF01.getGSAmplitude());

    //  Second, set the ramp-up and ramp-down times. The variable m_dMinRiseTime is the inverse of the slew rate [us*m/mT],
    //  the .getAmplitude() method delivers the amplitude in mT/m. The coil lead time is the minimum time needed between
    //  the beginning of an event block and the start time of the RF pulse shape. If the needed lead time is longer than
    //  the calculated minimum ramp-up time, then set the ramp-up time to the coil lead time.
    m_sGSliSel.setRampTimes(fSDSRoundUpGRT(std::max<long>((long)(m_dMinRiseTime * m_sGSliSel.getAmplitude()), SysProperties::getCoilCtrlLead())));

    //  Third, set the duration of the gradient. Gradient "duration" is defined as the duration of the ramp-up plus
    //  the duration of the plateau. The ramp-down duration is NOT included.
    m_sGSliSel.setDuration(fSDSRoundUpGRT(m_sSRF01.getDuration() + m_sGSliSel.getRampUpTime()));

    //  Fourth, prepare and check if the gradient is correctly prepared (slew rate and maximum amplitude not exceeded).
    if (!m_sGSliSel.prep())
        return m_sGSliSel.getNLSStatus();
    if (!m_sGSliSel.check())
        return m_sGSliSel.getNLSStatus();

    // NJM: slice select for refocusing pulse
    m_sGS_ref.setAmplitude(m_sSRF_ref.getGSAmplitude());
    m_sGS_ref.setRampTimes(fSDSRoundUpGRT(std::max<long>((long)(m_dMinRiseTime * m_sGS_ref.getAmplitude()), SysProperties::getCoilCtrlLead())));
    m_sGS_ref.setDuration(fSDSRoundUpGRT(m_sSRF_ref.getDuration() + m_sGS_ref.getRampUpTime()));
    if (!m_sGS_ref.prep())
        return m_sGS_ref.getNLSStatus();
    if (!m_sGS_ref.check())
        return m_sGS_ref.getNLSStatus();

    // NJM: crusher 
    m_sGS_crush.setMaxMagnitude(m_dGradMaxAmpl);
	m_sGS_crush.setMinRiseTime(m_dMinRiseTime);
	double numcalc = 1000.0 * 1000.0 * 1000.0 * 4.0 * M_PI;
	double dencalc1 = 2.0 * M_PI * 42.58E06;
	double dencalc2 = (double)rMrProt.sliceSeries().aFront().thickness() * 1.0E-3;
	double crusherMoment = numcalc / (dencalc1 * dencalc2);
	if (!m_sGS_crush.prepSymmetricTOTShortestTime(crusherMoment))
        return (m_sGS_crush.getNLSStatus());

    //  Finally, set start time of gradient to zero, as this is the first event in the event block. In general, setting
    //  the start time is not required for passing the check. However, it is required if the gradient is played out
    //  by using the .run() method rather than by using the fRTEI function in the runKernel method.
    //  Setting the start time is also a useful feature for getting timing information, e.g. in runKernel.
    m_sGSliSel.setStartTime(0);

    //  PREPARE AND CHECK THE SLICE REPHASE GRADIENT:
    //  Set the area equal to the slice select gradient from TE = 0 to the end (assuming a symmetric RF pulse).
    //  Use the shortest time possible.
    m_sGSliSelReph.setMaxMagnitude(m_dGradMaxAmpl);
    m_sGSliSelReph.setMinRiseTime(m_dMinRiseTime);
    if (!m_sGSliSelReph.prepSymmetricTOTShortestTime(-m_sGSliSel.getMomentum(m_sGSliSel.getDuration() - m_sSRF01.getDuration() / 2, m_sGSliSel.getTotalTime())))
        return m_sGSliSelReph.getNLSStatus();

    // NJM: combined slice-rewinder and crusher 
    m_sGS_rew_crush.setMaxMagnitude(m_dGradMaxAmpl);
    m_sGS_rew_crush.setMinRiseTime(m_dMinRiseTime);
    if (!m_sGS_rew_crush.prepSymmetricTOTShortestTime(crusherMoment - m_sGSliSel.getMomentum(m_sGSliSel.getDuration() - m_sSRF01.getDuration() / 2, m_sGSliSel.getTotalTime())))
        return m_sGS_rew_crush.getNLSStatus();

    //  PREPARE AND CHECK THE READOUT DEPHASING GRADIENT:
    //  Set the area equal to the readout gradient up to TE (assuming symmetric sampling).
    //  Use the shortest time possible.
    m_sGReadDeph.setMaxMagnitude(m_dGradMaxAmpl);
    m_sGReadDeph.setMinRiseTime(m_dMinRiseTime);
    if (!m_sGReadDeph.prepSymmetricTOTShortestTime(m_sGradRO.getMomentum(0, m_sGradRO.getRampUpTime() + (long)m_sADC01.getDuration() / 2))) // NJM: change from - to +
        return m_sGReadDeph.getNLSStatus();

    //  PREPARE AND CHECK THE SPOILER GRADIENT:
    //  Set the area to half that of the slice select gradient, and use the shortest time possible.
    m_sGSpoil.setMaxMagnitude(m_dGradMaxAmpl);
    m_sGSpoil.setMinRiseTime(m_dMinRiseTime);
    if (!m_sGSpoil.prepSymmetricTOTShortestTime(m_sGSliSel.getMomentum(0, m_sGSliSel.getDuration() - m_sSRF01.getDuration() / 2)))
        return m_sGSpoil.getNLSStatus();

    //  Calculate minimum required TE by finding the time-dominant (longest) gradient of m_sGReadDeph, m_sGPhasEnc, and m_sGSliSelReph.
    //  Note that m_sGSliSelReph is started when m_sGSliSel has ramped down, whereas m_sGReadDeph and m_sGPhasEnc are started at the
    //  end of the plateau of m_sGSliSel.

    //  First, see how long TE needs to be if m_sGReadDeph is longest:
    int32_t lMinRequiredTE = static_cast<int32_t>(m_sSRF01.getDuration() / 2 + m_sGReadDeph.getTotalTime() + m_sGradRO.getRampUpTime() + m_sADC01.getRoundedDuration() / 2);

    //  Second, compare this TE to the TE necessary if m_sGPhasEnc is longest:
    lMinRequiredTE = static_cast<int32_t>(std::max<long>(lMinRequiredTE, m_sSRF01.getDuration() / 2 + m_sGPhasEnc.getTotalTime() + m_sADC01.getRoundedDuration() / 2));

    //  Finally, compare this TE to the TE necessary if m_sGSliSelReph is longest:
    lMinRequiredTE
        = std::max<int32_t>(lMinRequiredTE, static_cast<int32_t>(m_sSRF01.getDuration() / 2 + m_sGSliSel.getRampDownTime() + m_sGSliSelReph.getTotalTime() + m_sADC01.getRoundedDuration() / 2));

    //  DETERMINE IF THE REQUIRED TIMING CAN BE ACCOMMODATED BY THE TE IN THE PROTOCOL:
    //  If the minimum required TE is larger than the TE specified in the protocol, then return an error code
    //  "MRI_SBB_SBB_NEGATIV_TEFILL". This error will cause the UI to increase the TE (pMrProt->te()[0]) until the
    //  prepare method no longer returns an error. Then the TE value that is found is consistent.
    // NJM: commenting out
    //if (lMinRequiredTE > (rMrProt.te()[0]))
    //    return MRI_SBB_SBB_NEGATIV_TEFILL;

    //  Set the start time of the readout gradient m_sGradRO
    m_sGradRO.setStartTime(fSDSRoundUpGRT(m_sGSliSel.getDuration() - m_sSRF01.getDuration() / 2 + rMrProt.te()[0] - m_sADC01.getRoundedDuration() / 2 - m_sGradRO.getRampUpTime()));

    //  Set the start time of the ADC event m_sADC01
    m_sADC01.setStartTime(m_sGradRO.getStartTime() + m_sGradRO.getRampUpTime());

    //  DETERMINE IF THE REQUIRED TIMING CAN BE ACCOMMODATED BY THE TR IN THE PROTOCOL:
    //  If the minimum required TR is larger than the TR chosen in the protocol, then return an error code
    //  "MRI_SBB_SBB_NEGATIV_TRFILL". This error will cause the UI to increase the TR (pMrProt->tr()[0]) until the
    //   prepare method no longer returns an error. Then the TR value is found that is consistent.

    const int32_t lMinRequiredTR = static_cast<int32_t>(m_sGSliSel.getDuration() - m_sSRF01.getDuration() / 2) + rMrProt.te()[0] + int32_t(m_sADC01.getDuration() / 2)
                                   + std::max<int32_t>(static_cast<int32_t>(m_sGPhasEncRew.getTotalTime()), static_cast<int32_t>(m_sGSpoil.getTotalTime()));
    if (lMinRequiredTR > rMrProt.tr()[0])
        return MRI_SBB_SBB_NEGATIV_TRFILL;

    //  PREPARE THE SYNCHRONIZATION EVENT:
    //  Since it occurs at the same time as the slice gradient at the beginning of the event block
    //  and is of shorter duration, it need not be included the timing checks.
    m_sOscBit.setCode(SYNCCODE_OSC0); // Internal designation for port 0
    m_sOscBit.setDuration(10);        // Duration in us

    //  Set receiver gain
    OnErrorReturn(fSSLSetRxGain(K_RX_GAIN_CODE_HIGH, rMrProt, rSeqLim));

    //  Prepare the slice position array
    OnErrorReturn(fSUPrepSlicePosArray(rMrProt, rSeqLim, m_asSLC.data()));

    //  Set sequence string for display in images.
    fSUSetSequenceString("fl", rMrProt, rSeqExpo);

    //  Fill export section
    rSeqExpo.setRFInfo(m_lLinesToMeasure * m_sSRF01.getRFInfo()); // Mandatory for SAR
    rSeqExpo.setMeasureTimeUsec(dMeasureTimeUsec);                // Mandatory for SAR
    rSeqExpo.setTotalMeasureTimeUsec(dMeasureTimeUsec);           // Mandatory for SAR
    rSeqExpo.setMeasuredPELines(m_lLinesToMeasure);               // Recommended
    rSeqExpo.setOnlineFFT(SEQ::ONLINE_FFT_PHASE);                 // Necessary for online reconstruction

    //  An ICE program must be specified in order for the MARS to be active during scan
    rSeqExpo.setICEProgramFilename("%SiemensIceProgs%\\IceProgramStandard"); // Only 2D reconstruction allowed

    //-----------------------------------------------------------------------------
    // Section for controlling Content Qualification
    //-----------------------------------------------------------------------------
    if (true == m_WIPParamTool.getBoolValue(rMrProt, WPT_POS_SETCONTENTQ_ENABLED))
    {
        int32_t selectionValue = m_WIPParamTool.getSelectionValue(rMrProt, WPT_POS_SETCONTENTQ_VALUE);
        rSeqLim.setContentQualification(static_cast<SEQ::ContentQualification>(selectionValue));
    }

    return lStatus;
}

//. -------------------------------------------------------------------------
//.. MiniFlash::check
//   Check lines at the border of k-space (gradient overflow, GSWD)
//. -------------------------------------------------------------------------
NLSStatus MiniFlash::check(MrProt& rMrProt, SeqLim& rSeqLim, MrProtocolData::SeqExpo& rSeqExpo, SEQCheckMode*)
{
    NLS_STATUS lStatus = MRI_SEQ_SEQU_NORMAL;

    int lL       = 0;
    int alLCk[4] = {0, 1, rSeqExpo.getMeasuredPELines() - 2, rSeqExpo.getMeasuredPELines() - 1}; // line numbers for first two and last two lines

    while (lL < 4)
    {
        OnErrorReturn(runKernel(rMrProt, rSeqLim, rSeqExpo, KERNEL_CHECK, 0, 0, alLCk[lL]));
        lL++;
    }

    return lStatus;
}

//. -------------------------------------------------------------------------
//.. MiniFlash::run
//   Run the sequence
//. -------------------------------------------------------------------------
NLSStatus MiniFlash::run(MrProt& rMrProt, SeqLim& rSeqLim, MrProtocolData::SeqExpo& rSeqExpo)
{
    NLS_STATUS lStatus = MRI_SEQ_SEQU_NORMAL;

    //  Initialize the sequence test.
    mSEQTest(rMrProt, rSeqLim, rSeqExpo, RTEB_ORIGIN_fSEQRunStart, 0, 0, 0, 0, 0);

    //  Send the delay between measurements (multiple measurements not used in MiniFLASH).
    OnErrorReturn(fSBBMeasRepetDelaysRun(rMrProt, rSeqLim, rSeqExpo, 0));

    //  Fill some entries of the measurement data header.
    //  These entries are constant for all lines and will not change from line to line.
    m_sADC01.getMDH().addToEvalInfoMask(MDH_ONLINE);                                             // add online priority processing
    m_sADC01.getMDH().setKSpaceCentreLineNo(static_cast<uint16_t>(rMrProt.kSpace().echoLine())); // (= Base Resolution / 2)
    m_sADC01.getMDH().setKSpaceCentrePartitionNo(0);                                             // 2D sequence

    // NJM: repeat for second readout
    m_sADC02.getMDH().addToEvalInfoMask(MDH_ONLINE);                                             // add online priority processing
    m_sADC02.getMDH().setKSpaceCentreLineNo(static_cast<uint16_t>(rMrProt.kSpace().echoLine())); // (= Base Resolution / 2)
    m_sADC02.getMDH().setKSpaceCentrePartitionNo(0);                                             // 2D sequence

    mSEQTest(rMrProt, rSeqLim, rSeqExpo, RTEB_ClockInitTR, 0, 0, m_asSLC[0].getSliceIndex(), 0, 0);

    //  Loop over lines.
    int32_t lCurrKernelCalls = 0;
    for (int32_t lLine = 0; lLine < m_lLinesToMeasure; lLine++)
    {
        lCurrKernelCalls++;
        if (!(lCurrKernelCalls % m_lLinesPerSec))
        {
            m_sADC01.setRelevantForMeasTime(true);
            m_sADC02.setRelevantForMeasTime(true); // NJM
        }
        else
        {
            m_sADC01.setRelevantForMeasTime(false);
            m_sADC02.setRelevantForMeasTime(false); // NJM
        }

        //  Fill some entries of the measurement data header. These entries can change from line to line.
        m_sADC01.getMDH().setFirstScanInSlice(lLine == 0);                    // only true if lLine = 0 (first line)
        m_sADC01.getMDH().setLastScanInSlice(lLine == m_lLinesToMeasure - 1); // only true if lLine = last line
        m_sADC01.getMDH().setLastScanInConcat(lLine == m_lLinesToMeasure - 1);
        m_sADC01.getMDH().setLastScanInMeas(lLine == m_lLinesToMeasure - 1);

        // NJM: shouldn't need this since entire MDH is copied into m_sADC02 in runKernel()
        m_sADC02.getMDH().setFirstScanInSlice(lLine == 0);                    // only true if lLine = 0 (first line)
        m_sADC02.getMDH().setLastScanInSlice(lLine == m_lLinesToMeasure - 1); // only true if lLine = last line
        m_sADC02.getMDH().setLastScanInConcat(lLine == m_lLinesToMeasure - 1);
        m_sADC02.getMDH().setLastScanInMeas(lLine == m_lLinesToMeasure - 1);

        //  Call Kernel function
        //  If the kernel is successful, then loop again; otherwise, exit run method immediately and return error code
        OnErrorReturn(runKernel(rMrProt, rSeqLim, rSeqExpo, KERNEL_IMAGE, 0, 0, lLine));
    }

    //  Finish the sequence test.
    mSEQTest(rMrProt, rSeqLim, rSeqExpo, RTEB_ORIGIN_fSEQRunFinish, 0, 0, 0, 0, 0);

    return lStatus;
}

//. -------------------------------------------------------------------------
//.. MiniFlash::runKernel
//   Play out primary event block
//. -------------------------------------------------------------------------
NLS_STATUS MiniFlash::runKernel(MrProt& rMrProt, SeqLim& rSeqLim, MrProtocolData::SeqExpo& rSeqExpo, long lKernelMode, long /* m_lSlice */, long /* m_lPartition */, long lLine)
{

    //
    // NJM: TODO: add lEcho as input argument to runKernel() 
    //


    NLS_STATUS lStatus = MRI_SEQ_SEQU_NORMAL;

    //  Prepare Phase encoding and rewinder gradients.
    if (!m_sGPhasEnc.prepPE(rMrProt, lLine - m_lCenterLine))
        return m_sGPhasEnc.getNLSStatus();
    if (!m_sGPhasEncRew.prepPE(rMrProt, m_lCenterLine - lLine))
        return m_sGPhasEncRew.getNLSStatus();

    //  Fill measurement data header. These entries also can change from line to line
    m_sADC01.getMDH().setClin(static_cast<uint16_t>(lLine));
    m_sADC01.getMDH().setPhaseFT(lLine == m_lLinesToMeasure - 1);

    //  NJM: for second echo: Fill measurement data header. These entries also can change from line to line
    m_sADC02.getMDH().setClin(static_cast<uint16_t>(lLine));
    m_sADC02.getMDH().setPhaseFT(lLine == m_lLinesToMeasure - 1);

    // NJM: also need to update echo index 
    m_sADC02.getMDH().setCeco(1);

    //  Prepare FrequencyPhase objects of the RF pulse.
    m_sSRF01zSet.prepSet(m_asSLC[0], m_sSRF01);
    m_sSRF01zNeg.prepNeg(m_asSLC[0], m_sSRF01);

    // NJM: do the same for the refocusing pulse 
    m_sSRF_ref_zSet.prepSet(m_asSLC[0], m_sSRF_ref);
    m_sSRF_ref_zNeg.prepNeg(m_asSLC[0], m_sSRF_ref);

    //  Prepare FrequencyPhase objects of the ADC.
    m_sADC01zSet.prepSet(m_asSLC[0], m_sADC01, m_sGradRO, lLine - m_lCenterLine, 0);
    m_sADC01zNeg.prepNeg(m_asSLC[0], m_sADC01, m_sGradRO, lLine - m_lCenterLine, 0);

    // NJM: repeat for second readout 
    m_sADC02zSet.prepSet(m_asSLC[0], m_sADC02, m_sGradRO, lLine - m_lCenterLine, 0);
    m_sADC02zNeg.prepNeg(m_asSLC[0], m_sADC02, m_sGradRO, lLine - m_lCenterLine, 0);

    // NJM: RF spoiling/cycling not needed here (90-degree phase difference for CPMG is built into pulses in MiniFlash::prepare() method)
    /*
    //  Calculate additional phase needed for RF spoiling and add to FreqPhase objects for RF pulse and ADC.
    m_dRFSpoilIncrement += RFSPOIL_INCREMENTdeg;
    m_dRFSpoilPhase += m_dRFSpoilIncrement;
    m_dRFSpoilPhase     = fmod(m_dRFSpoilPhase, static_cast<double>(RFMAXPHASEdeg));
    m_dRFSpoilIncrement = fmod(m_dRFSpoilIncrement, static_cast<double>(RFMAXPHASEdeg));

    m_sSRF01zSet.increasePhase(m_dRFSpoilPhase);
    m_sSRF01zNeg.decreasePhase(m_dRFSpoilPhase);
    m_sADC01zSet.increasePhase(m_dRFSpoilPhase);
    m_sADC01zNeg.decreasePhase(m_dRFSpoilPhase);
    */

    // clang-format off
    //  Initialize real time event block with rotation matrix from slice
    //fRTEBInit(m_asSLC[0].getROT_MATRIX());
    // - **************************************** S E Q U E N C E   T I M I N G ******************************************
    // - *           Start Time    |    NCO    |   SRF   |   ADC   |            Gradient Events            |   Sync
    // - *             (usec)      |   Event   |  Event  |  Event  |    phase   |   read     |    slice    |   Event
    // - *fRTEI(                   ,           ,         ,         ,            ,            ,             ,            );
    // - *****************************************************************************************************************


    // NJM: excitation / diffusion preparation module 
    if (lLine == 0) {

        fRTEBInit(m_asSLC[0].getROT_MATRIX());

        // NJM: slice-select for excitation
        lT = 0;
        fRTEI(0, 0, 0, 0, 0, 0, &m_sGSliSel, &m_sOscBit);

        // NJM: excitation pulse
        lT += fSDSRoundUpGRT(m_sGSliSel.getRampUpTime());
        fRTEI(lT, &m_sSRF01zSet, &m_sSRF01, 0, 0, 0, 0, 0); // NJM: excitation pulse 

        // NJM: reset rf phase
        lT += m_sSRF01.getDuration();
        fRTEI(lT, &m_sSRF01zNeg, 0, 0, 0, 0, 0, 0); // NJM: reset RF phase 

        // NJM: left diffusion gradient
        lT = fSDSRoundDownGRT( m_lPrepTimeUs/2 + m_sGSliSel.getTotalTime()/2 - m_sGS_ref.getTotalTime()/2 - m_sGS_rew_crush.getTotalTime() - m_sGS_Diff_ST.getTotalTime());
        fRTEI(lT, 0, 0, 0, 0, 0, &m_sGS_Diff_ST, 0);

        // NJM: combined slice rewinder and crusher 
        lT += fSDSRoundUpGRT(m_sGS_Diff_ST.getTotalTime());
        fRTEI(lT, 0, 0, 0, 0, 0, &m_sGS_rew_crush, 0);

        // NJM: slice-select for first refocusing pulse 
        lT += fSDSRoundUpGRT(m_sGS_rew_crush.getTotalTime());
        fRTEI(lT, 0, 0, 0, 0, 0, &m_sGS_ref, 0);

        // NJM: refocusing pulse 
        lT += fSDSRoundUpGRT(m_sGS_ref.getRampUpTime());
        fRTEI(lT, &m_sSRF_ref_zSet, &m_sSRF_ref, 0, 0, 0, 0, 0);

        // NJM: reset RF phase 
        lT += m_sSRF_ref.getDuration();
        fRTEI(lT, &m_sSRF_ref_zNeg, 0, 0, 0, 0, 0, 0);

        // NJM: right crusher 
        lT += fSDSRoundUpGRT(m_sGS_ref.getRampDownTime());
        fRTEI(lT, 0, 0, 0, 0, 0, &m_sGS_crush, 0);

        // NJM: right diffusion gradient 
        lT += fSDSRoundUpGRT(m_sGS_crush.getTotalTime());
        fRTEI(lT, 0, 0, 0, 0, 0, &m_sGS_Diff_ST, 0);

        // NJM: readout prephaser here 
        lT += fSDSRoundUpGRT(m_sGS_Diff_ST.getTotalTime());
        fRTEI(lT, 0, 0, 0, 0, &m_sGReadDeph, 0, 0);

        // NJM: left crusher for 2nd refocusing pulse 
        lT = fSDSRoundDownGRT( m_sGSliSel.getTotalTime()/2 + m_lPrepTimeUs + rMrProt.te()[0]/2 - m_sGS_ref.getTotalTime()/2 - m_sGS_crush.getTotalTime());
        fRTEI(lT, 0, 0, 0, 0, 0, &m_sGS_crush, 0);

        // NJM: delay until start of next refocusing pulse (this is where all other kernels will start)
        lT += fSDSRoundUpGRT(m_sGS_crush.getTotalTime());
        fRTEI(lT, 0, 0, 0, 0, 0, 0, 0);

        // NJM: end the real time block 
        OnErrorReturn(fRTEBFinish());

    } // NJM: end of preparation block 

    // NJM: start another block for current point along echo train 
    fRTEBInit(m_asSLC[0].getROT_MATRIX());

    // NJM: reset time 
    lT = 0;

    // NJM: slice-select for refocusing pulse 
    fRTEI(lT, 0, 0, 0, 0, 0, &m_sGS_ref, 0);

    // NJM: refocusing pulse 
    lT += fSDSRoundUpGRT(m_sGS_ref.getRampUpTime());
    fRTEI(lT, &m_sSRF_ref_zSet, &m_sSRF_ref, 0, 0, 0, 0, 0);

    // NJM: reset RF phase and play phase encode gradients
    lT += m_sSRF_ref.getDuration();
    fRTEI(lT, &m_sSRF_ref_zNeg, 0, 0, &m_sGPhasEnc, 0, 0, 0);

    // NJM: crusher
    lT += fSDSRoundUpGRT(m_sGS_ref.getRampDownTime());
    fRTEI(lT, 0, 0, 0, 0, 0, &m_sGS_crush, 0);

    // NJM: first readout gradient 
    lT = fSDSRoundDownGRT(m_sGS_ref.getTotalTime()/2 + rMrProt.te()[0]/2 + m_sGradRO.getRampDownTime()/2 - m_sGradRO.getDuration());
    fRTEI(lT, 0, 0, 0, 0, &m_sGradRO, 0, 0);

    // NJM: play first ADC 
    lT += fSDSRoundUpGRT(m_sGradRO.getRampUpTime());
    fRTEI(lT, &m_sADC01zSet, 0, &m_sADC01, 0, 0, 0, 0);

    // NJM: reset first ADC phase 
    lT += fSDSRoundUpGRT(m_sADC01.getDuration());
    fRTEI(lT, &m_sADC01zNeg, 0, 0, 0, 0, 0, 0);

    // NJM: second readout gradient 
    //lT = fSDSRoundDownGRT(m_sGS_ref.getTotalTime()/2 + rMrProt.te()[0]/2 - m_sGradRO.getRampDownTime()/2);
    fRTEI(lT, 0, 0, 0, 0, &m_sGradRO, 0, 0);

    // NJM: play second ADC 
    lT += fSDSRoundUpGRT(m_sGradRO.getRampUpTime());
    fRTEI(lT, &m_sADC02zSet, 0, &m_sADC02, 0, 0, 0, 0);

    // NJM: reset second ADC phase 
    lT += fSDSRoundUpGRT(m_sADC02.getDuration());
    fRTEI(lT, &m_sADC02zNeg, 0, 0, 0, 0, 0, 0);

    // NJM: phase encode rewinder 
    lT = fSDSRoundDownGRT( m_sGS_ref.getTotalTime()/2 + rMrProt.te()[0] - m_sGS_ref.getTotalTime()/2 - m_sGPhasEncRew.getTotalTime());
    fRTEI(lT, 0, 0, 0, &m_sGPhasEncRew, 0, 0, 0);

    // NJM: crusher 
    lT = fSDSRoundDownGRT( m_sGS_ref.getTotalTime()/2 + rMrProt.te()[0] - m_sGS_ref.getTotalTime()/2 - m_sGPhasEncRew.getTotalTime());
    fRTEI(lT, 0, 0, 0, 0, 0, &m_sGS_crush, 0);

    // NJM: delay until end of crusher 
    lT += fSDSRoundUpGRT(m_sGS_crush.getTotalTime());
    fRTEI(lT, 0, 0, 0, 0, 0, 0, 0);

    // NJM: end the event block 
    OnErrorReturn(fRTEBFinish());


    // Call sequence unit test.
    mSEQTest(rMrProt, rSeqLim, rSeqExpo, (lKernelMode == KERNEL_CHECK) ? RTEB_ORIGIN_fSEQCheck : RTEB_ORIGIN_fSEQRunKernel, 10, lLine, m_asSLC[0].getSliceIndex(), 0, 0);

    mSEQTest(rMrProt, rSeqLim, rSeqExpo, RTEB_ClockCheck, 10, lLine, m_asSLC[0].getSliceIndex(), 0, 0);

    //  End real time event block.
    //OnErrorReturn(fRTEBFinish()); // NJM: alread done

    return lStatus;
}

NLSStatus MiniFlash::receive(SeqLim& rSeqLim, SeqExpo& rSeqExpo, const SEQData& rSEQData)
{
    if (0 == std::strcmp("Demo.ISeqSendReceiveDemoPlugIn", rSEQData.getID()))
    {
        m_SeqSerMessage = (char*)rSEQData.getData();
        MRTRACE("MiniFlash receive SEQData '%s'", m_SeqSerMessage.c_str());
    }

    return MRI_SEQ_SEQU_NORMAL;
}

NLSStatus MiniFlash::deliver(SeqLim& rSeqLim, SeqExpo& rSeqExpo, SEQData& rSEQData)
{
    if (0 == std::strcmp("Demo.ISeqSendReceiveDemoPlugIn", rSEQData.getID()))
    {
        rSEQData.allocData(static_cast<int32_t>(m_SeqSerMessage.size() + 1));
        rSEQData.setData(m_SeqSerMessage.data(), m_SeqSerMessage.size() + 1);
        MRTRACE("MiniFlash deliver SEQData '%s'", m_SeqSerMessage.c_str());
    }

    return MRI_SEQ_SEQU_NORMAL;
}
