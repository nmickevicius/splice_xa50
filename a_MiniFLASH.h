// --------------------------------------------------------------------------------
//   Copyright (C) Siemens Healthcare GmbH, 2015-2018. All Rights Reserved. Confidential.
// --------------------------------------------------------------------------------
//
//  \file  MrImagingFW\seq\a_MiniFLASH\a_MiniFLASH.h
//
//  \brief Declarations for a_MiniFLASH.cpp
//
//     Remarks: This is the demo sequence MiniFLASH.
//              DO NOT base any diagnosis on images generated by this sequence.
//
//    -----------------------------------------------------------------------------

#pragma once

#ifndef a_MiniFlash_h
#define a_MiniFlash_h

//------------------------------
// Includes
//------------------------------
#include "MrGlobalDefinitions/MrResult.h"    // Messages
#include "MrImaging/libSeqUtil/libSeqUtil.h" // Support functions
#include "MrImagingFW/WIPParameterTool/WIPParameterTool.h"
#include "MrImagingFW/libSBBFW/StdSeqIF.h"                    // Standard Sequence interface
#include "MrImagingFW/libSeqUtilFW/libSeqUtilFW.h"            // Support functions
#include "MrMeasSrv/SeqFW/libGSL/libGSL.h"                    // fGSL... prototypes
#include "MrMeasSrv/SeqFW/libSSL/libSSL.h"                    // fSSL... prototypes
#include "MrMeasSrv/SeqIF/libRT/sFREQ_PHASE.h"                // sFREQ_PHASE
#include "MrMeasSrv/SeqIF/libRT/sGRAD_PULSE.h"                // sGRAD_PULSE
#include "MrMeasSrv/SeqIF/libRT/sREADOUT.h"                   // sREADOUT
#include "MrMeasSrv/SeqIF/libRT/sRF_PULSE.h"                  // sRF_PULSE
#include "MrProtSrv/Domain/CoreNative/SeqLim.h"               // SeqLim
#include "MrProtSrv/Domain/MrProtData/MrProt/MrProt.h"        // MrProt
#include "MrProtSrv/Domain/MrProtData/MrProt/SeqIF/SeqExpo.h" // SeqExpo

#include <array>

#ifdef BUILD_SEQU
#define __OWNER
#endif

// The following include is necessary for the DLL generation
#include "MrGlobalDefinitions/ImpExpCtrl.h"

#define WPT_POS_SETCONTENTQ_ENABLED 0
#define WPT_POS_SETCONTENTQ_VALUE 1

// NJM:
#define MAX(a,b) (((a)>(b))?(a):(b))

//------------------------------
// Forward declarations
//------------------------------

class MrProt;
class SeqLim;
class SeqExpo;
class Sequence;

namespace SEQ_NAMESPACE
{
// forward declaration
class MiniFlashUI;

/**
 * @brief The MiniFlash sequence class is intended as a demo implementation for teaching purposes.
 * Therefore, all functions are implemented in a "minimalistic" fashion.
 */
class __IMP_EXP MiniFlash : public StdSeqIF
{
  public:
    //  --------------------------------------------------------------------------
    //
    //  Name        :  MiniFlash::MiniFlash
    //
    //  Description :
    /// \brief         Initialization of class members
    //
    //  Return      :  void
    //
    //  --------------------------------------------------------------------------
    MiniFlash();

    //  --------------------------------------------------------------------------
    //
    //  Name        :  MiniFlash::~MiniFlash
    //
    //  Description :
    /// \brief         Destructor. Deletes existing MiniFlashUI instances.
    //
    //  Return      :  void
    //
    //  --------------------------------------------------------------------------
    virtual ~MiniFlash() = default;

    MiniFlash(const MiniFlash& right) = delete;
    MiniFlash& operator=(const MiniFlash& right) = delete;
    MiniFlash(MiniFlash&& right)                 = delete;
    MiniFlash& operator=(MiniFlash&& right) = delete;

    // NJM: for calculation of diffusion gradient duration
    int32_t calcdelta(int32_t tramp, int32_t tsep, int32_t traster, double bvalue, double gmax);


    //  --------------------------------------------------------------------------
    //
    //   Name        :  MiniFlash::initialize
    //
    //   Description :
    ///  \brief         Initialization of the sequence       </b>
    ///
    ///                 The "hard limits" for the protocol parameters are set.
    ///                 The hard limits define the maximum allowed range for each parameter.
    ///                 Also, any parameters that are not dependent on MrProt are defined.
    ///                 On the host, the MiniFlashUI object (m_pUI) will actually contain sensible data after MiniFlash::initialize.
    ///                 On the measurement system, it is basically an empty object.
    ///
    //   Return      :  NLS status
    //                  If running on a Windows-32-machine, the status will indicate if the creation of MiniFlashUI was successful.
    //                  If not running on a Windows-32-machine, the return value is always "MRI_SEQ_SEQU_NORMAL"
    //
    //   --------------------------------------------------------------------------
    NLSStatus initialize(SeqLim& rSeqLim) override;

    //  --------------------------------------------------------------------------
    //
    //  Name        :  MiniFlash::prepare
    //
    //  Description :
    ///  \brief <b>     Preparation of the sequence during binary search and prior to sequence execution  </b>
    ///
    ///                 This method verifies that the current protocol is valid
    ///                 (i.e. a sequence run with the given parameters is possible).
    ///
    ///                 The method is called during the binary search (graphical user interface of EXAM or POET)
    ///                 and prior to executing a sequence.
    ///
    //  Return      :  NLS status
    //
    //  --------------------------------------------------------------------------
    NLSStatus prepare(MrProt& rMrProt, SeqLim& rSeqLim, MrProtocolData::SeqExpo& rSeqExpo) override;

    //  --------------------------------------------------------------------------
    //
    //  Name        :  MiniFlash::check
    //
    //  Description :
    /// \brief  <b>    Check of the sequence for gradient stimulation </b>
    ///
    ///                This method is called on the host by the framework prior to a measurement to ensure that
    ///                 - no gradient amplitude or slew rate overflow occurs
    ///                 - the stimulation will not exceed the threshold
    ///
    //  Return      :  NLS status
    //
    //  --------------------------------------------------------------------------
    NLSStatus check(MrProt& rMrProt, SeqLim& rSeqLim, MrProtocolData::SeqExpo& rSeqExpo, SEQCheckMode* pSEQCheckMode) override;

    //  --------------------------------------------------------------------------
    //
    //  Name        :  MiniFlash::run
    //
    //  Description :
    ///     \brief     Execution of the sequence
    ///
    ///                This method executes the sequence.
    ///                On the scanner, it is performed only on the MARS (linux-64).
    ///             It normally performs the looping over K space.
    ///
    //  Return      :  NLS status
    //
    //  --------------------------------------------------------------------------
    NLSStatus run(MrProt& rMrProt, SeqLim& rSeqLim, MrProtocolData::SeqExpo& rSeqExpo) override;

    //   --------------------------------------------------------------------------
    //
    //   Name        :  MiniFlash::runKernel
    //
    //   Description :
    ///  \brief <b>     Executes the basic timing of the real-time sequence.   </b>
    ///
    ///                 This method is the fundamental repeat unit of the sequence.
    ///                 It is called by the run method and typically acquires one or more lines in k-Space.
    ///
    //   Return      :  NLS status
    //
    //   --------------------------------------------------------------------------
    NLS_STATUS runKernel(MrProt& rMrProt, SeqLim& rSeqLim, MrProtocolData::SeqExpo& rSeqExpo, long lKernelMode, long lSlice, long lPartition, long lLine) override;

    NLSStatus receive(SeqLim& rSeqLim, SeqExpo& rSeqExpo, const SEQData& rSEQData) override;

    NLSStatus deliver(SeqLim& rSeqLim, SeqExpo& rSeqExpo, SEQData& rSEQData) override;

    //  --------------------------------------------------------------
    //
    //  Name        :  getUI
    //
    //  Description :
    /// \brief <b>     Returns the pointer to the MiniFlashUI class  </b>
    ///
    ///                This method is only sensible on the host.
    ///                On the measurement system, it will return an almost empty object.
    ///
    //  Return      :  MiniFlashUI*
    //
    //  --------------------------------------------------------------
    const MiniFlashUI* getUI(void) const;

  protected:
    // * ---------------------------------------------------------------------- *
    // * RF spoiling phase                                                      *
    // * ---------------------------------------------------------------------- *
    double m_dRFSpoilPhase{0.0};

    // * ---------------------------------------------------------------------- *
    // * Increment of the Rf spoiling phase                                     *
    // * ---------------------------------------------------------------------- *
    double m_dRFSpoilIncrement{0.0};

    // * ---------------------------------------------------------------------- *
    // * Index of the k-space center line                                       *
    // * ---------------------------------------------------------------------- *
    int32_t m_lCenterLine{0};

    // * ---------------------------------------------------------------------- *
    // * Minimum Gradient Rise Time                                             *
    // * ---------------------------------------------------------------------- *
    double m_dMinRiseTime{100000.0};

    // * ---------------------------------------------------------------------- *
    // * Maximum Gradient Amplitude                                             *
    // * ---------------------------------------------------------------------- *
    double m_dGradMaxAmpl{0.0};

    // * ---------------------------------------------------------------------- *
    // * Number of phase encoding lines measured per second                     *
    // * ---------------------------------------------------------------------- *
    int32_t m_lLinesPerSec{0};

    // * ---------------------------------------------------------------------- *
    // * Number of phase encoding lines with iPAT                               *
    // * m_lLinesToMeasure and m_lLinesToMeasureMax are identical if iPAT is    *
    // * disabled.                                                              *
    // * ---------------------------------------------------------------------- *
    int32_t m_lLinesToMeasure{0};

    // NJM: diffusion preparation time in microseconds
    int32_t m_lPrepTimeUs{100000};

    // NJM: counter to keep track of time in runKernel 
    int32_t lT{0};

    // NJM: b-value 
    double m_bValue{500.0};

    // * ---------------------------------------------------------------------- *
    // * Slice position information (rotation matrices and shifts)              *
    // * ---------------------------------------------------------------------- *
    std::array<sSLICE_POS, 1> m_asSLC; // MiniFLASH is a single-slice sequence but
    // some utility functions require the use of an array as most sequences are multi-slice

    // * ---------------------------------------------------------------------- *
    // * RF Pulses and NCO                                                      *
    // * ---------------------------------------------------------------------- *
    sRF_PULSE_SINC m_sSRF01{"fl_templ_ex"};    // RF transmit waveform envelope
    sFREQ_PHASE    m_sSRF01zSet{"sSRF01zSet"}; // Set Frequency and phase offset for RF pulse
    sFREQ_PHASE    m_sSRF01zNeg{"sSRF01zNeg"}; // Reset synthesizer back to base

    // * ---------------------------------------------------------------------- *
    // * Read Out and NCO                                                       *
    // * ---------------------------------------------------------------------- *
    sREADOUT    m_sADC01{"sADC01"};         // Signal detection event
    sFREQ_PHASE m_sADC01zSet{"sADC01zSet"}; // Set Frequency and phase offset for ADC
    sFREQ_PHASE m_sADC01zNeg{"sADC01zNeg"}; // Reset synthesizer back to base
    


    // * ---------------------------------------------------------------------- *
    // * Gradient Pulses                                                        *
    // * ---------------------------------------------------------------------- *
    sGRAD_PULSE    m_sGSliSel{"sGSliSel"};         // Gradient during RF transmit for slice selection
    sGRAD_PULSE    m_sGSliSelReph{"sGSliSelReph"}; // Gradient to refocus slice selection gradient (after TE = 0)
    sGRAD_PULSE_RO m_sGradRO{"m_sGradRO"};         // Gradient during echo detection
    sGRAD_PULSE    m_sGReadDeph{"m_sGReadDeph"};   // Gradient to preset readout
    sGRAD_PULSE_PE m_sGPhasEnc{"sGPhasEnc"};       // Gradient for phase encoding
    sGRAD_PULSE_PE m_sGPhasEncRew{"sGPhasEncRew"}; // Gradient for rewinding
    sGRAD_PULSE    m_sGSpoil{"m_sGSpoil"};         // Gradient for incoherent steady-state in slice direction

    /* NJM: additions for splice */
    sGRAD_PULSE    m_sGS_Diff_ST{"sGS_Diff_ST"};   // NJM: stejkal-tanner diffusion gradient
    sGRAD_PULSE    m_sGS_ref{"sGS_ref"}; // NJM: slice-selct for refocusing pulses 
    sGRAD_PULSE    m_sGS_crush{"sGS_crush"}; // NJM: crusher gradient
    sGRAD_PULSE    m_sGS_rew_crush{"sGS_rew_crush"}; // NJM: combined rewinder/crusher gradient bewteen excitation and first refocusing pulse 
    sRF_PULSE_SINC m_sSRF_ref{"sSRF_ref"};    // NJM: refocusing pulse
    sFREQ_PHASE    m_sSRF_ref_zSet{"sSRF_ref_zSet"}; // NJM
    sFREQ_PHASE    m_sSRF_ref_zNeg{"sSRF_ref_zNeg"}; // NJM
    sREADOUT       m_sADC02{"sADC02"};         // NJM
    sFREQ_PHASE    m_sADC02zSet{"sADC02zSet"}; // NJM
    sFREQ_PHASE    m_sADC02zNeg{"sADC02zNeg"}; // NJM

    
    // * ---------------------------------------------------------------------- *
    // * Sync Objects                                                           *
    // * ---------------------------------------------------------------------- *
    sSYNC_OSC m_sOscBit{"m_sOscBit"}; // Synchronization event for oscilloscope trigger

    // --------------------------------------------------------------------------------------------
    ///  \brief    The associated WIPParamTool instance
    // --------------------------------------------------------------------------------------------
    WPT_NAMESPACE::WIPParameterTool m_WIPParamTool;

    std::string m_SeqSerMessage;
};
}; // namespace SEQ_NAMESPACE

#endif // end of a_MiniFlash_h
